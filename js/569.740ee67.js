/*! For license information please see LICENSES */
(window.webpackJsonp=window.webpackJsonp||[]).push([[569],{1178:function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.validateBasic=e.wNAF=void 0;const n=r(381),o=r(265),c=BigInt(0),l=BigInt(1);e.wNAF=function(t,e){const r=(t,e)=>{const r=e.negate();return t?r:e},n=t=>({windows:Math.ceil(e/t)+1,windowSize:2**(t-1)});return{constTimeNegate:r,unsafeLadder(e,r){let p=t.ZERO,n=e;for(;r>c;)r&l&&(p=p.add(n)),n=n.double(),r>>=l;return p},precomputeWindow(t,e){const{windows:r,windowSize:o}=n(e),c=[];let p=t,base=p;for(let t=0;t<r;t++){base=p,c.push(base);for(let i=1;i<o;i++)base=base.add(p),c.push(base);p=base.double()}return c},wNAF(e,o,c){const{windows:f,windowSize:d}=n(e);let p=t.ZERO,h=t.BASE;const mask=BigInt(2**e-1),y=2**e,m=BigInt(e);for(let t=0;t<f;t++){const e=t*d;let n=Number(c&mask);c>>=m,n>d&&(n-=y,c+=l);const f=e,w=e+Math.abs(n)-1,E=t%2!=0,B=n<0;0===n?h=h.add(r(E,o[f])):p=p.add(r(B,o[w]))}return{p:p,f:h}},wNAFCached(t,e,r,n){const o=t._WINDOW_SIZE||1;let c=e.get(t);return c||(c=this.precomputeWindow(t,o),1!==o&&e.set(t,n(c))),this.wNAF(o,c,r)}}},e.validateBasic=function(t){return(0,n.validateField)(t.Fp),(0,o.validateObject)(t,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...(0,n.nLength)(t.n,t.nBitLength),...t,p:t.Fp.ORDER})}},1179:function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.createHasher=e.isogenyMap=e.hash_to_field=e.expand_message_xof=e.expand_message_xmd=void 0;const n=r(381),o=r(265);const c=o.bytesToNumberBE;function l(t,e){if(t<0||t>=1<<8*e)throw new Error(`bad I2OSP call: value=${t} length=${e}`);const r=Array.from({length:e}).fill(0);for(let i=e-1;i>=0;i--)r[i]=255&t,t>>>=8;return new Uint8Array(r)}function f(a,b){const t=new Uint8Array(a.length);for(let i=0;i<a.length;i++)t[i]=a[i]^b[i];return t}function d(t){if(!(t instanceof Uint8Array))throw new Error("Uint8Array expected")}function h(t){if(!Number.isSafeInteger(t))throw new Error("number expected")}function y(t,e,r,n){d(t),d(e),h(r),e.length>255&&(e=n((0,o.concatBytes)((0,o.utf8ToBytes)("H2C-OVERSIZE-DST-"),e)));const{outputLen:c,blockLen:y}=n,m=Math.ceil(r/c);if(m>255)throw new Error("Invalid xmd length");const w=(0,o.concatBytes)(e,l(e.length,1)),E=l(0,y),B=l(r,2),b=new Array(m),v=n((0,o.concatBytes)(E,t,B,l(0,1),w));b[0]=n((0,o.concatBytes)(v,l(1,1),w));for(let i=1;i<=m;i++){const t=[f(v,b[i-1]),l(i+1,1),w];b[i]=n((0,o.concatBytes)(...t))}return(0,o.concatBytes)(...b).slice(0,r)}function m(t,e,r,n,c){if(d(t),d(e),h(r),e.length>255){const t=Math.ceil(2*n/8);e=c.create({dkLen:t}).update((0,o.utf8ToBytes)("H2C-OVERSIZE-DST-")).update(e).digest()}if(r>65535||e.length>255)throw new Error("expand_message_xof: invalid lenInBytes");return c.create({dkLen:r}).update(t).update(l(r,2)).update(e).update(l(e.length,1)).digest()}function w(t,e,r){(0,o.validateObject)(r,{DST:"string",p:"bigint",m:"isSafeInteger",k:"isSafeInteger",hash:"hash"});const{p:p,k:l,m:f,hash:w,expand:E,DST:B}=r;d(t),h(e);const v=function(t){if(t instanceof Uint8Array)return t;if("string"==typeof t)return(0,o.utf8ToBytes)(t);throw new Error("DST must be Uint8Array or string")}(B),S=p.toString(2).length,x=Math.ceil((S+l)/8),O=e*f*x;let T;if("xmd"===E)T=y(t,v,O,w);else if("xof"===E)T=m(t,v,O,l,w);else{if("_internal_pass"!==E)throw new Error('expand must be "xmd" or "xof"');T=t}const u=new Array(e);for(let i=0;i<e;i++){const t=new Array(f);for(let e=0;e<f;e++){const r=x*(e+i*f),o=T.subarray(r,r+x);t[e]=(0,n.mod)(c(o),p)}u[i]=t}return u}e.expand_message_xmd=y,e.expand_message_xof=m,e.hash_to_field=w,e.isogenyMap=function(t,map){const e=map.map((i=>Array.from(i).reverse()));return(r,n)=>{const[o,c,l,f]=e.map((e=>e.reduce(((e,i)=>t.add(t.mul(e,r),i)))));return r=t.div(o,c),n=t.mul(n,t.div(l,f)),{x:r,y:n}}},e.createHasher=function(t,e,r){if("function"!=typeof e)throw new Error("mapToCurve() must be defined");return{hashToCurve(n,o){const u=w(n,2,{...r,DST:r.DST,...o}),c=t.fromAffine(e(u[0])),l=t.fromAffine(e(u[1])),f=c.add(l).clearCofactor();return f.assertValidity(),f},encodeToCurve(n,o){const u=w(n,1,{...r,DST:r.encodeDST,...o}),c=t.fromAffine(e(u[0])).clearCofactor();return c.assertValidity(),c}}}},1180:function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.createCurve=e.getHash=void 0;const n=r(1181),o=r(320),c=r(746);function l(t){return{hash:t,hmac:(e,...r)=>(0,n.hmac)(t,e,(0,o.concatBytes)(...r)),randomBytes:o.randomBytes}}e.getHash=l,e.createCurve=function(t,e){const r=e=>(0,c.weierstrass)({...t,...l(e)});return Object.freeze({...r(e),create:r})}},265:function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.validateObject=e.createHmacDrbg=e.bitMask=e.bitSet=e.bitGet=e.bitLen=e.utf8ToBytes=e.equalBytes=e.concatBytes=e.ensureBytes=e.numberToVarBytesBE=e.numberToBytesLE=e.numberToBytesBE=e.bytesToNumberLE=e.bytesToNumberBE=e.hexToBytes=e.hexToNumber=e.numberToHexUnpadded=e.bytesToHex=void 0;const n=BigInt(0),o=BigInt(1),c=BigInt(2),l=a=>a instanceof Uint8Array,f=Array.from({length:256},((t,i)=>i.toString(16).padStart(2,"0")));function d(t){if(!l(t))throw new Error("Uint8Array expected");let e="";for(let i=0;i<t.length;i++)e+=f[t[i]];return e}function h(t){const e=t.toString(16);return 1&e.length?`0${e}`:e}function y(t){if("string"!=typeof t)throw new Error("hex string expected, got "+typeof t);return BigInt(""===t?"0":`0x${t}`)}function m(t){if("string"!=typeof t)throw new Error("hex string expected, got "+typeof t);const e=t.length;if(e%2)throw new Error("padded hex string expected, got unpadded hex of length "+e);const r=new Uint8Array(e/2);for(let i=0;i<r.length;i++){const e=2*i,n=t.slice(e,e+2),o=Number.parseInt(n,16);if(Number.isNaN(o)||o<0)throw new Error("Invalid byte sequence");r[i]=o}return r}function w(t,e){return m(t.toString(16).padStart(2*e,"0"))}function E(...t){const e=new Uint8Array(t.reduce(((t,a)=>t+a.length),0));let r=0;return t.forEach((a=>{if(!l(a))throw new Error("Uint8Array expected");e.set(a,r),r+=a.length})),e}e.bytesToHex=d,e.numberToHexUnpadded=h,e.hexToNumber=y,e.hexToBytes=m,e.bytesToNumberBE=function(t){return y(d(t))},e.bytesToNumberLE=function(t){if(!l(t))throw new Error("Uint8Array expected");return y(d(Uint8Array.from(t).reverse()))},e.numberToBytesBE=w,e.numberToBytesLE=function(t,e){return w(t,e).reverse()},e.numberToVarBytesBE=function(t){return m(h(t))},e.ensureBytes=function(title,t,e){let r;if("string"==typeof t)try{r=m(t)}catch(e){throw new Error(`${title} must be valid hex string, got "${t}". Cause: ${e}`)}else{if(!l(t))throw new Error(`${title} must be hex string or Uint8Array`);r=Uint8Array.from(t)}const n=r.length;if("number"==typeof e&&n!==e)throw new Error(`${title} expected ${e} bytes, got ${n}`);return r},e.concatBytes=E,e.equalBytes=function(t,e){if(t.length!==e.length)return!1;for(let i=0;i<t.length;i++)if(t[i]!==e[i])return!1;return!0},e.utf8ToBytes=function(t){if("string"!=typeof t)throw new Error("utf8ToBytes expected string, got "+typeof t);return new Uint8Array((new TextEncoder).encode(t))},e.bitLen=function(t){let e;for(e=0;t>n;t>>=o,e+=1);return e},e.bitGet=function(t,e){return t>>BigInt(e)&o};e.bitSet=(t,e,r)=>t|(r?o:n)<<BigInt(e);e.bitMask=t=>(c<<BigInt(t-1))-o;const B=data=>new Uint8Array(data),v=t=>Uint8Array.from(t);e.createHmacDrbg=function(t,e,r){if("number"!=typeof t||t<2)throw new Error("hashLen must be a number");if("number"!=typeof e||e<2)throw new Error("qByteLen must be a number");if("function"!=typeof r)throw new Error("hmacFn must be a function");let n=B(t),o=B(t),i=0;const c=()=>{n.fill(1),o.fill(0),i=0},l=(...b)=>r(o,n,...b),f=(t=B())=>{o=l(v([0]),t),n=l(),0!==t.length&&(o=l(v([1]),t),n=l())},d=()=>{if(i++>=1e3)throw new Error("drbg: tried 1000 values");let t=0;const r=[];for(;t<e;){n=l();const e=n.slice();r.push(e),t+=n.length}return E(...r)};return(t,e)=>{let r;for(c(),f(t);!(r=e(d()));)f();return c(),r}};const S={bigint:t=>"bigint"==typeof t,function:t=>"function"==typeof t,boolean:t=>"boolean"==typeof t,string:t=>"string"==typeof t,isSafeInteger:t=>Number.isSafeInteger(t),array:t=>Array.isArray(t),field:(t,object)=>object.Fp.isValid(t),hash:t=>"function"==typeof t&&Number.isSafeInteger(t.outputLen)};e.validateObject=function(object,t,e={}){const r=(t,e,r)=>{const n=S[e];if("function"!=typeof n)throw new Error(`Invalid validator "${e}", expected function`);const o=object[t];if(!(r&&void 0===o||n(o,object)))throw new Error(`Invalid param ${String(t)}=${o} (${typeof o}), expected ${e}`)};for(const[e,n]of Object.entries(t))r(e,n,!1);for(const[t,n]of Object.entries(e))r(t,n,!0);return object}},381:function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.hashToPrivateScalar=e.FpSqrtEven=e.FpSqrtOdd=e.Field=e.nLength=e.FpIsSquare=e.FpDiv=e.FpInvertBatch=e.FpPow=e.validateField=e.isNegativeLE=e.FpSqrt=e.tonelliShanks=e.invert=e.pow2=e.pow=e.mod=void 0;const n=r(265),o=BigInt(0),c=BigInt(1),l=BigInt(2),f=BigInt(3),d=BigInt(4),h=BigInt(5),y=BigInt(8);BigInt(9),BigInt(16);function m(a,b){const t=a%b;return t>=o?t:b+t}function w(t,e,r){if(r<=o||e<o)throw new Error("Expected power/modulo > 0");if(r===c)return o;let n=c;for(;e>o;)e&c&&(n=n*t%r),t=t*t%r,e>>=c;return n}function E(t,e){if(t===o||e<=o)throw new Error(`invert: expected positive integers, got n=${t} mod=${e}`);let a=m(t,e),b=e,r=o,n=c,u=c,l=o;for(;a!==o;){const q=b/a,t=b%a,e=r-u*q,o=n-l*q;b=a,a=t,r=u,n=l,u=e,l=o}if(b!==c)throw new Error("invert: does not exist");return m(r,e)}function B(t){const e=(t-c)/l;let r,n,f;for(r=t-c,n=0;r%l===o;r/=l,n++);for(f=l;f<t&&w(f,e,t)!==t-c;f++);if(1===n){const e=(t+c)/d;return function(t,r){const n=t.pow(r,e);if(!t.eql(t.sqr(n),r))throw new Error("Cannot find square root");return n}}const h=(r+c)/l;return function(t,o){if(t.pow(o,e)===t.neg(t.ONE))throw new Error("Cannot find square root");let l=n,g=t.pow(t.mul(t.ONE,f),r),d=t.pow(o,h),b=t.pow(o,r);for(;!t.eql(b,t.ONE);){if(t.eql(b,t.ZERO))return t.ZERO;let e=1;for(let r=t.sqr(b);e<l&&!t.eql(r,t.ONE);e++)r=t.sqr(r);const r=t.pow(g,c<<BigInt(l-e-1));g=t.sqr(r),d=t.mul(d,r),b=t.mul(b,g),l=e}return d}}function v(t){if(t%d===f){const e=(t+c)/d;return function(t,r){const n=t.pow(r,e);if(!t.eql(t.sqr(n),r))throw new Error("Cannot find square root");return n}}if(t%y===h){const e=(t-h)/y;return function(t,r){const n=t.mul(r,l),o=t.pow(n,e),c=t.mul(r,o),i=t.mul(t.mul(c,l),o),f=t.mul(c,t.sub(i,t.ONE));if(!t.eql(t.sqr(f),r))throw new Error("Cannot find square root");return f}}return B(t)}e.mod=m,e.pow=w,e.pow2=function(t,e,r){let n=t;for(;e-- >o;)n*=n,n%=r;return n},e.invert=E,e.tonelliShanks=B,e.FpSqrt=v;e.isNegativeLE=(t,e)=>(m(t,e)&c)===c;const S=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function x(t,e,r){if(r<o)throw new Error("Expected power > 0");if(r===o)return t.ONE;if(r===c)return e;let p=t.ONE,n=e;for(;r>o;)r&c&&(p=t.mul(p,n)),n=t.sqr(n),r>>=c;return p}function O(t,e){const r=new Array(e.length),n=e.reduce(((e,n,i)=>t.is0(n)?e:(r[i]=e,t.mul(e,n))),t.ONE),o=t.inv(n);return e.reduceRight(((e,n,i)=>t.is0(n)?e:(r[i]=t.mul(e,r[i]),t.mul(e,n))),o),r}function T(t,e){const r=void 0!==e?e:t.toString(2).length;return{nBitLength:r,nByteLength:Math.ceil(r/8)}}e.validateField=function(t){const e=S.reduce(((map,t)=>(map[t]="function",map)),{ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"});return(0,n.validateObject)(t,e)},e.FpPow=x,e.FpInvertBatch=O,e.FpDiv=function(t,e,r){return t.mul(e,"bigint"==typeof r?E(r,t.ORDER):t.inv(r))},e.FpIsSquare=function(t){const e=(t.ORDER-c)/l;return r=>{const p=t.pow(r,e);return t.eql(p,t.ZERO)||t.eql(p,t.ONE)}},e.nLength=T,e.Field=function(t,e,r=!1,l={}){if(t<=o)throw new Error(`Expected Fp ORDER > 0, got ${t}`);const{nBitLength:f,nByteLength:d}=T(t,e);if(d>2048)throw new Error("Field lengths over 2048 bytes are not supported");const h=v(t),y=Object.freeze({ORDER:t,BITS:f,BYTES:d,MASK:(0,n.bitMask)(f),ZERO:o,ONE:c,create:e=>m(e,t),isValid:e=>{if("bigint"!=typeof e)throw new Error("Invalid field element: expected bigint, got "+typeof e);return o<=e&&e<t},is0:t=>t===o,isOdd:t=>(t&c)===c,neg:e=>m(-e,t),eql:(t,e)=>t===e,sqr:e=>m(e*e,t),add:(e,r)=>m(e+r,t),sub:(e,r)=>m(e-r,t),mul:(e,r)=>m(e*r,t),pow:(t,e)=>x(y,t,e),div:(e,r)=>m(e*E(r,t),t),sqrN:t=>t*t,addN:(t,e)=>t+e,subN:(t,e)=>t-e,mulN:(t,e)=>t*e,inv:e=>E(e,t),sqrt:l.sqrt||(t=>h(y,t)),invertBatch:t=>O(y,t),cmov:(a,b,t)=>t?b:a,toBytes:t=>r?(0,n.numberToBytesLE)(t,d):(0,n.numberToBytesBE)(t,d),fromBytes:t=>{if(t.length!==d)throw new Error(`Fp.fromBytes: expected ${d}, got ${t.length}`);return r?(0,n.bytesToNumberLE)(t):(0,n.bytesToNumberBE)(t)}});return Object.freeze(y)},e.FpSqrtOdd=function(t,e){if(!t.isOdd)throw new Error("Field doesn't have isOdd");const r=t.sqrt(e);return t.isOdd(r)?r:t.neg(r)},e.FpSqrtEven=function(t,e){if(!t.isOdd)throw new Error("Field doesn't have isOdd");const r=t.sqrt(e);return t.isOdd(r)?t.neg(r):r},e.hashToPrivateScalar=function(t,e,r=!1){const o=(t=(0,n.ensureBytes)("privateHash",t)).length,l=T(e).nByteLength+8;if(l<24||o<l||o>1024)throw new Error(`hashToPrivateScalar: expected ${l}-1024 bytes of input, got ${o}`);return m(r?(0,n.bytesToNumberLE)(t):(0,n.bytesToNumberBE)(t),e-c)+c}},746:function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.mapToCurveSimpleSWU=e.SWUFpSqrtRatio=e.weierstrass=e.weierstrassPoints=e.DER=void 0;const n=r(381),o=r(265),c=r(265),l=r(1178);const{bytesToNumberBE:f,hexToBytes:d}=o;e.DER={Err:class extends Error{constructor(t=""){super(t)}},_parseInt(data){const{Err:t}=e.DER;if(data.length<2||2!==data[0])throw new t("Invalid signature integer tag");const r=data[1],n=data.subarray(2,r+2);if(!r||n.length!==r)throw new t("Invalid signature integer: wrong length");if(128&n[0])throw new t("Invalid signature integer: negative");if(0===n[0]&&!(128&n[1]))throw new t("Invalid signature integer: unnecessary leading zero");return{d:f(n),l:data.subarray(r+2)}},toSig(t){const{Err:r}=e.DER,data="string"==typeof t?d(t):t;if(!(data instanceof Uint8Array))throw new Error("ui8a expected");let n=data.length;if(n<2||48!=data[0])throw new r("Invalid signature tag");if(data[1]!==n-2)throw new r("Invalid signature: incorrect length");const{d:o,l:c}=e.DER._parseInt(data.subarray(2)),{d:s,l:l}=e.DER._parseInt(c);if(l.length)throw new r("Invalid signature: left bytes after parsing");return{r:o,s:s}},hexFromSig(t){const e=s=>8&Number.parseInt(s[0],16)?"00"+s:s,r=t=>{const e=t.toString(16);return 1&e.length?`0${e}`:e},s=e(r(t.s)),n=e(r(t.r)),o=s.length/2,c=n.length/2,l=r(o),f=r(c);return`30${r(c+o+4)}02${f}${n}02${l}${s}`}};const h=BigInt(0),y=BigInt(1),m=BigInt(2),w=BigInt(3),E=BigInt(4);function B(t){const e=function(t){const e=(0,l.validateBasic)(t);o.validateObject(e,{a:"field",b:"field"},{allowedPrivateKeyLengths:"array",wrapPrivateKey:"boolean",isTorsionFree:"function",clearCofactor:"function",allowInfinityPoint:"boolean",fromBytes:"function",toBytes:"function"});const{endo:r,Fp:n,a:a}=e;if(r){if(!n.eql(a,n.ZERO))throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");if("object"!=typeof r||"bigint"!=typeof r.beta||"function"!=typeof r.splitScalar)throw new Error("Expected endomorphism with beta: bigint and splitScalar: function")}return Object.freeze({...e})}(t),{Fp:r}=e,f=e.toBytes||((t,e,n)=>{const a=e.toAffine();return o.concatBytes(Uint8Array.from([4]),r.toBytes(a.x),r.toBytes(a.y))}),d=e.fromBytes||(t=>{const e=t.subarray(1);return{x:r.fromBytes(e.subarray(0,r.BYTES)),y:r.fromBytes(e.subarray(r.BYTES,2*r.BYTES))}});function m(t){const{a:a,b:b}=e,n=r.sqr(t),o=r.mul(n,t);return r.add(r.add(o,r.mul(t,a)),b)}if(!r.eql(r.sqr(e.Gy),m(e.Gx)))throw new Error("bad generator point: equation left != right");function E(t){return"bigint"==typeof t&&h<t&&t<e.n}function B(t){if(!E(t))throw new Error("Expected valid bigint: 0 < bigint < curve.n")}function v(t){const{allowedPrivateKeyLengths:r,nByteLength:l,wrapPrivateKey:f,n:d}=e;if(r&&"bigint"!=typeof t){if(t instanceof Uint8Array&&(t=o.bytesToHex(t)),"string"!=typeof t||!r.includes(t.length))throw new Error("Invalid key");t=t.padStart(2*l,"0")}let h;try{h="bigint"==typeof t?t:o.bytesToNumberBE((0,c.ensureBytes)("private key",t,l))}catch(e){throw new Error(`private key must be ${l} bytes, hex or bigint, not ${typeof t}`)}return f&&(h=n.mod(h,d)),B(h),h}const S=new Map;function x(t){if(!(t instanceof O))throw new Error("ProjectivePoint expected")}class O{constructor(t,e,n){if(this.px=t,this.py=e,this.pz=n,null==t||!r.isValid(t))throw new Error("x required");if(null==e||!r.isValid(e))throw new Error("y required");if(null==n||!r.isValid(n))throw new Error("z required")}static fromAffine(p){const{x:t,y:e}=p||{};if(!p||!r.isValid(t)||!r.isValid(e))throw new Error("invalid affine point");if(p instanceof O)throw new Error("projective point not allowed");const n=i=>r.eql(i,r.ZERO);return n(t)&&n(e)?O.ZERO:new O(t,e,r.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(t){const e=r.invertBatch(t.map((p=>p.pz)));return t.map(((p,i)=>p.toAffine(e[i]))).map(O.fromAffine)}static fromHex(t){const e=O.fromAffine(d((0,c.ensureBytes)("pointHex",t)));return e.assertValidity(),e}static fromPrivateKey(t){return O.BASE.multiply(v(t))}_setWindowSize(t){this._WINDOW_SIZE=t,S.delete(this)}assertValidity(){if(this.is0()){if(e.allowInfinityPoint)return;throw new Error("bad point: ZERO")}const{x:t,y:n}=this.toAffine();if(!r.isValid(t)||!r.isValid(n))throw new Error("bad point: x or y not FE");const o=r.sqr(n),c=m(t);if(!r.eql(o,c))throw new Error("bad point: equation left != right");if(!this.isTorsionFree())throw new Error("bad point: not in prime-order subgroup")}hasEvenY(){const{y:t}=this.toAffine();if(r.isOdd)return!r.isOdd(t);throw new Error("Field doesn't support isOdd")}equals(t){x(t);const{px:e,py:n,pz:o}=this,{px:c,py:l,pz:f}=t,d=r.eql(r.mul(e,f),r.mul(c,o)),h=r.eql(r.mul(n,f),r.mul(l,o));return d&&h}negate(){return new O(this.px,r.neg(this.py),this.pz)}double(){const{a:a,b:b}=e,t=r.mul(b,w),{px:n,py:o,pz:c}=this;let l=r.ZERO,f=r.ZERO,d=r.ZERO,h=r.mul(n,n),y=r.mul(o,o),m=r.mul(c,c),E=r.mul(n,o);return E=r.add(E,E),d=r.mul(n,c),d=r.add(d,d),l=r.mul(a,d),f=r.mul(t,m),f=r.add(l,f),l=r.sub(y,f),f=r.add(y,f),f=r.mul(l,f),l=r.mul(E,l),d=r.mul(t,d),m=r.mul(a,m),E=r.sub(h,m),E=r.mul(a,E),E=r.add(E,d),d=r.add(h,h),h=r.add(d,h),h=r.add(h,m),h=r.mul(h,E),f=r.add(f,h),m=r.mul(o,c),m=r.add(m,m),h=r.mul(m,E),l=r.sub(l,h),d=r.mul(m,y),d=r.add(d,d),d=r.add(d,d),new O(l,f,d)}add(t){x(t);const{px:n,py:o,pz:c}=this,{px:l,py:f,pz:d}=t;let h=r.ZERO,y=r.ZERO,m=r.ZERO;const a=e.a,E=r.mul(e.b,w);let B=r.mul(n,l),v=r.mul(o,f),S=r.mul(c,d),T=r.add(n,o),A=r.add(l,f);T=r.mul(T,A),A=r.add(B,v),T=r.sub(T,A),A=r.add(n,c);let R=r.add(l,d);return A=r.mul(A,R),R=r.add(B,S),A=r.sub(A,R),R=r.add(o,c),h=r.add(f,d),R=r.mul(R,h),h=r.add(v,S),R=r.sub(R,h),m=r.mul(a,A),h=r.mul(E,S),m=r.add(h,m),h=r.sub(v,m),m=r.add(v,m),y=r.mul(h,m),v=r.add(B,B),v=r.add(v,B),S=r.mul(a,S),A=r.mul(E,A),v=r.add(v,S),S=r.sub(B,S),S=r.mul(a,S),A=r.add(A,S),B=r.mul(v,A),y=r.add(y,B),B=r.mul(R,A),h=r.mul(T,h),h=r.sub(h,B),B=r.mul(T,v),m=r.mul(R,m),m=r.add(m,B),new O(h,y,m)}subtract(t){return this.add(t.negate())}is0(){return this.equals(O.ZERO)}wNAF(t){return A.wNAFCached(this,S,t,(t=>{const e=r.invertBatch(t.map((p=>p.pz)));return t.map(((p,i)=>p.toAffine(e[i]))).map(O.fromAffine)}))}multiplyUnsafe(t){const n=O.ZERO;if(t===h)return n;if(B(t),t===y)return this;const{endo:o}=e;if(!o)return A.unsafeLadder(this,t);let{k1neg:c,k1:l,k2neg:f,k2:d}=o.splitScalar(t),m=n,w=n,E=this;for(;l>h||d>h;)l&y&&(m=m.add(E)),d&y&&(w=w.add(E)),E=E.double(),l>>=y,d>>=y;return c&&(m=m.negate()),f&&(w=w.negate()),w=new O(r.mul(w.px,o.beta),w.py,w.pz),m.add(w)}multiply(t){B(t);let n,o,c=t;const{endo:l}=e;if(l){const{k1neg:t,k1:e,k2neg:f,k2:d}=l.splitScalar(c);let{p:h,f:y}=this.wNAF(e),{p:m,f:w}=this.wNAF(d);h=A.constTimeNegate(t,h),m=A.constTimeNegate(f,m),m=new O(r.mul(m.px,l.beta),m.py,m.pz),n=h.add(m),o=y.add(w)}else{const{p:p,f:t}=this.wNAF(c);n=p,o=t}return O.normalizeZ([n,o])[0]}multiplyAndAddUnsafe(t,a,b){const e=O.BASE,r=(t,a)=>a!==h&&a!==y&&t.equals(e)?t.multiply(a):t.multiplyUnsafe(a),n=r(this,a).add(r(t,b));return n.is0()?void 0:n}toAffine(t){const{px:e,py:n,pz:o}=this,c=this.is0();null==t&&(t=c?r.ONE:r.inv(o));const l=r.mul(e,t),f=r.mul(n,t),d=r.mul(o,t);if(c)return{x:r.ZERO,y:r.ZERO};if(!r.eql(d,r.ONE))throw new Error("invZ was invalid");return{x:l,y:f}}isTorsionFree(){const{h:t,isTorsionFree:r}=e;if(t===y)return!0;if(r)return r(O,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){const{h:t,clearCofactor:r}=e;return t===y?this:r?r(O,this):this.multiplyUnsafe(e.h)}toRawBytes(t=!0){return this.assertValidity(),f(O,this,t)}toHex(t=!0){return o.bytesToHex(this.toRawBytes(t))}}O.BASE=new O(e.Gx,e.Gy,r.ONE),O.ZERO=new O(r.ZERO,r.ONE,r.ZERO);const T=e.nBitLength,A=(0,l.wNAF)(O,e.endo?Math.ceil(T/2):T);return{CURVE:e,ProjectivePoint:O,normPrivateKeyToScalar:v,weierstrassEquation:m,isWithinCurveOrder:E}}function v(t,e){const q=t.ORDER;let r=h;for(let t=q-y;t%m===h;t/=m)r+=y;const n=r,o=m<<n-y-y,c=o*m,l=(q-y)/c,f=(l-y)/m,d=c-y,B=o,v=t.pow(e,l),S=t.pow(e,(l+y)/m);let x=(u,e)=>{let r=v,o=t.pow(e,d),c=t.sqr(o);c=t.mul(c,e);let l=t.mul(u,c);l=t.pow(l,f),l=t.mul(l,o),o=t.mul(l,e),c=t.mul(l,u);let h=t.mul(c,o);l=t.pow(h,B);let w=t.eql(l,t.ONE);o=t.mul(c,S),l=t.mul(h,r),c=t.cmov(o,c,w),h=t.cmov(l,h,w);for(let i=n;i>y;i--){let e=i-m;e=m<<e-y;let n=t.pow(h,e);const l=t.eql(n,t.ONE);o=t.mul(c,r),r=t.mul(r,r),n=t.mul(h,r),c=t.cmov(o,c,l),h=t.cmov(n,h,l)}return{isValid:w,value:c}};if(t.ORDER%E===w){const r=(t.ORDER-w)/E,n=t.sqrt(t.neg(e));x=(u,e)=>{let o=t.sqr(e);const c=t.mul(u,e);o=t.mul(o,c);let l=t.pow(o,r);l=t.mul(l,c);const f=t.mul(l,n),d=t.mul(t.sqr(l),e),h=t.eql(d,u);return{isValid:h,value:t.cmov(f,l,h)}}}return x}e.weierstrassPoints=B,e.weierstrass=function(t){const r=function(t){const e=(0,l.validateBasic)(t);return o.validateObject(e,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...e})}(t),{Fp:f,n:d}=r,m=f.BYTES+1,w=2*f.BYTES+1;function E(a){return n.mod(a,d)}function v(a){return n.invert(a,d)}const{ProjectivePoint:S,normPrivateKeyToScalar:x,weierstrassEquation:O,isWithinCurveOrder:T}=B({...r,toBytes(t,e,r){const a=e.toAffine(),n=f.toBytes(a.x),c=o.concatBytes;return r?c(Uint8Array.from([e.hasEvenY()?2:3]),n):c(Uint8Array.from([4]),n,f.toBytes(a.y))},fromBytes(t){const e=t.length,head=t[0],r=t.subarray(1);if(e!==m||2!==head&&3!==head){if(e===w&&4===head){return{x:f.fromBytes(r.subarray(0,f.BYTES)),y:f.fromBytes(r.subarray(f.BYTES,2*f.BYTES))}}throw new Error(`Point of length ${e} was invalid. Expected ${m} compressed bytes or ${w} uncompressed bytes`)}{const t=o.bytesToNumberBE(r);if(!(h<(n=t)&&n<f.ORDER))throw new Error("Point is not on curve");const e=O(t);let c=f.sqrt(e);return 1==(1&head)!==((c&y)===y)&&(c=f.neg(c)),{x:t,y:c}}var n}}),A=t=>o.bytesToHex(o.numberToBytesBE(t,r.nByteLength));function R(t){return t>d>>y}const I=(b,t,e)=>o.bytesToNumberBE(b.slice(t,e));class N{constructor(t,s,e){this.r=t,this.s=s,this.recovery=e,this.assertValidity()}static fromCompact(t){const e=r.nByteLength;return t=(0,c.ensureBytes)("compactSignature",t,2*e),new N(I(t,0,e),I(t,e,2*e))}static fromDER(t){const{r:r,s:s}=e.DER.toSig((0,c.ensureBytes)("DER",t));return new N(r,s)}assertValidity(){if(!T(this.r))throw new Error("r must be 0 < r < CURVE.n");if(!T(this.s))throw new Error("s must be 0 < s < CURVE.n")}addRecoveryBit(t){return new N(this.r,this.s,t)}recoverPublicKey(t){const{r:e,s:s,recovery:n}=this,o=D((0,c.ensureBytes)("msgHash",t));if(null==n||![0,1,2,3].includes(n))throw new Error("recovery id invalid");const l=2===n||3===n?e+r.n:e;if(l>=f.ORDER)throw new Error("recovery id 2 or 3 invalid");const d=0==(1&n)?"02":"03",h=S.fromHex(d+A(l)),y=v(l),m=E(-o*y),w=E(s*y),B=S.BASE.multiplyAndAddUnsafe(h,m,w);if(!B)throw new Error("point at infinify");return B.assertValidity(),B}hasHighS(){return R(this.s)}normalizeS(){return this.hasHighS()?new N(this.r,E(-this.s),this.recovery):this}toDERRawBytes(){return o.hexToBytes(this.toDERHex())}toDERHex(){return e.DER.hexFromSig({r:this.r,s:this.s})}toCompactRawBytes(){return o.hexToBytes(this.toCompactHex())}toCompactHex(){return A(this.r)+A(this.s)}}const F={isValidPrivateKey(t){try{return x(t),!0}catch(t){return!1}},normPrivateKeyToScalar:x,randomPrivateKey:()=>{const t=r.randomBytes(f.BYTES+8),e=n.hashToPrivateScalar(t,d);return o.numberToBytesBE(e,r.nByteLength)},precompute:(t=8,e=S.BASE)=>(e._setWindowSize(t),e.multiply(BigInt(3)),e)};function L(t){const e=t instanceof Uint8Array,r="string"==typeof t,n=(e||r)&&t.length;return e?n===m||n===w:r?n===2*m||n===2*w:t instanceof S}const U=r.bits2int||function(t){const e=o.bytesToNumberBE(t),n=8*t.length-r.nBitLength;return n>0?e>>BigInt(n):e},D=r.bits2int_modN||function(t){return E(U(t))},P=o.bitMask(r.nBitLength);function _(t){if("bigint"!=typeof t)throw new Error("bigint expected");if(!(h<=t&&t<P))throw new Error(`bigint expected < 2^${r.nBitLength}`);return o.numberToBytesBE(t,r.nByteLength)}function Z(t,e,n=$){if(["recovered","canonical"].some((t=>t in n)))throw new Error("sign() legacy options not supported");const{hash:l,randomBytes:d}=r;let{lowS:m,prehash:w,extraEntropy:B}=n;null==m&&(m=!0),t=(0,c.ensureBytes)("msgHash",t),w&&(t=(0,c.ensureBytes)("prehashed msgHash",l(t)));const O=D(t),A=x(e),I=[_(A),_(O)];if(null!=B){const t=!0===B?d(f.BYTES):B;I.push((0,c.ensureBytes)("extraEntropy",t,f.BYTES))}const F=o.concatBytes(...I),L=O;return{seed:F,k2sig:function(t){const e=U(t);if(!T(e))return;const r=v(e),q=S.BASE.multiply(e).toAffine(),n=E(q.x);if(n===h)return;const s=E(r*E(L+n*A));if(s===h)return;let o=(q.x===n?0:2)|Number(q.y&y),c=s;return m&&R(s)&&(c=function(s){return R(s)?E(-s):s}(s),o^=1),new N(n,c,o)}}}const $={lowS:r.lowS,prehash:!1},H={lowS:r.lowS,prehash:!1};return S.BASE._setWindowSize(8),{CURVE:r,getPublicKey:function(t,e=!0){return S.fromPrivateKey(t).toRawBytes(e)},getSharedSecret:function(t,e,r=!0){if(L(t))throw new Error("first arg must be private key");if(!L(e))throw new Error("second arg must be public key");return S.fromHex(e).multiply(x(t)).toRawBytes(r)},sign:function(t,e,n=$){const{seed:c,k2sig:l}=Z(t,e,n),f=r;return o.createHmacDrbg(f.hash.outputLen,f.nByteLength,f.hmac)(c,l)},verify:function(t,n,o,l=H){var f;const d=t;if(n=(0,c.ensureBytes)("msgHash",n),o=(0,c.ensureBytes)("publicKey",o),"strict"in l)throw new Error("options.strict was renamed to lowS");const{lowS:h,prehash:y}=l;let m,w;try{if("string"==typeof d||d instanceof Uint8Array)try{m=N.fromDER(d)}catch(t){if(!(t instanceof e.DER.Err))throw t;m=N.fromCompact(d)}else{if("object"!=typeof d||"bigint"!=typeof d.r||"bigint"!=typeof d.s)throw new Error("PARSE");{const{r:t,s:s}=d;m=new N(t,s)}}w=S.fromHex(o)}catch(t){if("PARSE"===t.message)throw new Error("signature must be Signature instance, Uint8Array or hex string");return!1}if(h&&m.hasHighS())return!1;y&&(n=r.hash(n));const{r:B,s:s}=m,x=D(n),O=v(s),T=E(x*O),A=E(B*O),R=null===(f=S.BASE.multiplyAndAddUnsafe(w,T,A))||void 0===f?void 0:f.toAffine();return!!R&&E(R.x)===B},ProjectivePoint:S,Signature:N,utils:F}},e.SWUFpSqrtRatio=v,e.mapToCurveSimpleSWU=function(t,e){if(n.validateField(t),!t.isValid(e.A)||!t.isValid(e.B)||!t.isValid(e.Z))throw new Error("mapToCurveSimpleSWU: invalid opts");const r=v(t,e.Z);if(!t.isOdd)throw new Error("Fp.isOdd is not implemented!");return u=>{let n,o,c,l,f,d,h,y;n=t.sqr(u),n=t.mul(n,e.Z),o=t.sqr(n),o=t.add(o,n),c=t.add(o,t.ONE),c=t.mul(c,e.B),l=t.cmov(e.Z,t.neg(o),!t.eql(o,t.ZERO)),l=t.mul(l,e.A),o=t.sqr(c),d=t.sqr(l),f=t.mul(d,e.A),o=t.add(o,f),o=t.mul(o,c),d=t.mul(d,l),f=t.mul(d,e.B),o=t.add(o,f),h=t.mul(n,c);const{isValid:m,value:w}=r(o,d);y=t.mul(n,u),y=t.mul(y,w),h=t.cmov(h,c,m),y=t.cmov(y,w,m);const E=t.isOdd(u)===t.isOdd(y);return y=t.cmov(t.neg(y),y,E),h=t.div(h,l),{x:h,y:y}}}}}]);